#!/usr/bin/env node
/* eslint-disable no-console */
import path from 'node:path';
import fs from 'node:fs';
import fsp from 'node:fs/promises';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, '../..');
const SRC_DIR = path.resolve(ROOT, 'src', 'components');
const COMPONENT_MAP = path.resolve(ROOT, 'docs/dev/refs/component-map.json');
const COMPONENTS_DIR = path.resolve(ROOT, 'docs/dev/refs/components');
const OVERVIEW_MD = path.resolve(ROOT, 'docs/dev/00-overview.md');
const COVERAGE_JSON = path.resolve(ROOT, 'docs/dev/refs/docs-coverage.json');
const POSIX = p => p.split(path.sep).join('/');

let writeFileIfChanged, ensureDir, log;
async function initUtils() {
  try {
    const utils = await import('./_utils.mjs');
    writeFileIfChanged = utils.writeFileIfChanged;
    ensureDir = utils.ensureDir;
    log = utils.log ?? ((...a) => console.log('[docs:coverage]', ...a));
  } catch {
    log = (...a) => console.log('[docs:coverage]', ...a);
    ensureDir = async dir => fsp.mkdir(dir, { recursive: true });
    writeFileIfChanged = async (file, next) => {
      let prev = null;
      try {
        prev = await fsp.readFile(file, 'utf8');
      } catch {}
      if (prev === next) return { changed: false };
      await ensureDir(path.dirname(file));
      await fsp.writeFile(file, next, 'utf8');
      return { changed: true };
    };
  }
}

const hasFile = p => fs.existsSync(p);
const read = p => fsp.readFile(p, 'utf8');

function detBanner(title) {
  return [
    '<!--',
    ' Auto-generated by scripts/docs/generate-docs-coverage.mjs',
    ' Title: ' + title,
    ' Deterministic banner (no timestamps).',
    '-->',
    '',
  ].join('\n');
}

function parseComponentMap() {
  try {
    const content = fs.readFileSync(COMPONENT_MAP, 'utf8');
    const data = JSON.parse(content);
    return data.components || [];
  } catch {
    log('warning: could not read component-map.json');
    return [];
  }
}

function analyzeComponentPage(componentName) {
  const pagePath = path.join(COMPONENTS_DIR, `${componentName}.md`);
  if (!hasFile(pagePath)) {
    return { hasPage: false, bannerOk: false, propsWithDesc: 0, totalProps: 0 };
  }

  try {
    const content = fs.readFileSync(pagePath, 'utf8');
    const bannerOk = content.includes('<!--\n Auto-generated by scripts/docs/generate-component-docs.mjs');
    
    // Parse props table to count descriptions
    const propsTableMatch = content.match(/\| Name \| Type \| Optional \| Default \| Description \|[\s\S]*?(?=\n\n|$)/);
    if (!propsTableMatch) {
      return { hasPage: true, bannerOk, propsWithDesc: 0, totalProps: 0 };
    }

    const tableContent = propsTableMatch[0];
    const rows = tableContent.split('\n').filter(line => line.includes('|') && !line.includes('---'));
    
    let totalProps = 0;
    let propsWithDesc = 0;

    for (const row of rows) {
      const columns = row.split('|').map(col => col.trim());
      if (columns.length >= 6) {
        const description = columns[5];
        totalProps++;
        if (description && description.trim() && description !== '_No explicit props detected_') {
          propsWithDesc++;
        }
      }
    }

    return { hasPage: true, bannerOk, propsWithDesc, totalProps };
  } catch (error) {
    log(`warning: could not analyze ${componentName}.md:`, error.message);
    return { hasPage: true, bannerOk: false, propsWithDesc: 0, totalProps: 0 };
  }
}

function generateCoverageData() {
  const components = parseComponentMap();
  if (!components.length) {
    log('skip: no components found in component-map.json');
    return null;
  }

  // Deterministic sort
  const sortedComponents = components
    .map(c => c.name)
    .sort((a, b) => a.localeCompare(b, 'en'));

  let totalComponents = sortedComponents.length;
  let componentsWithPage = 0;
  let propsTotal = 0;
  let propsWithDescriptions = 0;
  let bannerOkCount = 0;
  const offenders = [];

  for (const componentName of sortedComponents) {
    const analysis = analyzeComponentPage(componentName);
    
    if (analysis.hasPage) {
      componentsWithPage++;
      if (analysis.bannerOk) bannerOkCount++;
      
      propsTotal += analysis.totalProps;
      propsWithDescriptions += analysis.propsWithDesc;
      
      if (analysis.totalProps > 0 && analysis.propsWithDesc === 0) {
        offenders.push(componentName);
      }
    }
  }

  // Sort offenders A-Z and take top 10
  const topOffenders = offenders.sort((a, b) => a.localeCompare(b, 'en')).slice(0, 10);

  return {
    generatedBy: 'generate-docs-coverage.mjs',
    metrics: {
      totalComponents,
      componentsWithPage,
      propsTotal,
      propsWithDescriptions,
      bannerOkCount,
    },
    percentages: {
      componentCoverage: totalComponents > 0 ? (componentsWithPage / totalComponents) : 0,
      propDescriptionCoverage: propsTotal > 0 ? (propsWithDescriptions / propsTotal) : 0,
      bannerCoverage: totalComponents > 0 ? (bannerOkCount / totalComponents) : 0,
    },
    topOffenders,
    generatedAt: 'deterministic', // no timestamp
  };
}

function renderCoverageBlock(coverageData) {
  const { metrics, percentages, topOffenders } = coverageData;
  
  const pctComponents = (percentages.componentCoverage * 100).toFixed(2);
  const pctProps = (percentages.propDescriptionCoverage * 100).toFixed(2);
  
  const lines = [];
  lines.push('<!-- AUTO-GEN:COVERAGE-START -->');
  lines.push('');
  lines.push('### Docs Coverage (auto-generated)');
  lines.push('');
  lines.push(`- Components documented: **${metrics.componentsWithPage}/${metrics.totalComponents}** (${pctComponents}%)`);
  lines.push(`- Props with descriptions: **${metrics.propsWithDescriptions}/${metrics.propsTotal}** (${pctProps}%)`);
  lines.push('');
  
  if (topOffenders.length > 0) {
    lines.push('**Least documented components (up to 10):**');
    for (const offender of topOffenders) {
      lines.push(`- ${offender} (0 props described)`);
    }
    lines.push('');
  }
  
  lines.push('<!-- AUTO-GEN:COVERAGE-END -->');
  return lines.join('\n');
}

async function upsertOverviewCoverage(coverageData) {
  const coverageBlock = renderCoverageBlock(coverageData);
  const AUTO_START = '<!-- AUTO-GEN:COVERAGE-START -->';
  const AUTO_END = '<!-- AUTO-GEN:COVERAGE-END -->';
  
  let out = coverageBlock;
  try {
    const existing = await fsp.readFile(OVERVIEW_MD, 'utf8');
    const s = existing.indexOf(AUTO_START);
    const e = existing.indexOf(AUTO_END);
    
    if (s !== -1 && e !== -1 && e > s) {
      // Replace existing block
      out = existing.slice(0, s) + coverageBlock + existing.slice(e + AUTO_END.length);
    } else {
      // Append new block
      out = existing + '\n\n' + coverageBlock;
    }
  } catch {
    // File doesn't exist, use just the coverage block
  }
  
  const res = await writeFileIfChanged(OVERVIEW_MD, out);
  log(`${res.changed ? 'updated' : 'unchanged'}: ${POSIX(path.relative(ROOT, OVERVIEW_MD))}`);
}

async function main() {
  await initUtils();
  log('start');

  if (!hasFile(SRC_DIR)) {
    log('skip: src/components directory not found.');
    log('done');
    process.exit(0);
  }

  if (!hasFile(COMPONENT_MAP)) {
    log('skip: component-map.json not found.');
    log('done');
    process.exit(0);
  }

  const coverageData = generateCoverageData();
  if (!coverageData) {
    log('skip: no coverage data generated.');
    log('done');
    process.exit(0);
  }

  // Write coverage JSON
  await ensureDir(path.dirname(COVERAGE_JSON));
  const coverageJson = JSON.stringify(coverageData, null, 2);
  const coverageRes = await writeFileIfChanged(COVERAGE_JSON, coverageJson);
  log(`${coverageRes.changed ? 'wrote' : 'unchanged'}: ${POSIX(path.relative(ROOT, COVERAGE_JSON))}`);

  // Update overview with coverage block
  await upsertOverviewCoverage(coverageData);

  const { metrics, percentages } = coverageData;
  log(`done (${metrics.componentsWithPage}/${metrics.totalComponents} components, ${metrics.propsWithDescriptions}/${metrics.propsTotal} props described)`);
  process.exit(0);
}

main().catch(e => {
  console.error('[docs:coverage] non-fatal error:', e?.message || e);
  process.exit(0);
});
