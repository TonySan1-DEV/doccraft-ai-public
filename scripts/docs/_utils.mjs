import fs from 'fs';
import fsp from 'fs/promises';
import path from 'path';
import { execSync } from 'node:child_process';

export async function ensureDir(p) {
  await fsp.mkdir(p, { recursive: true });
}

export async function writeFileIfChanged(filePath, content) {
  await ensureDir(path.dirname(filePath));
  let old = null;
  try {
    old = await fsp.readFile(filePath, 'utf8');
  } catch {}
  if (old === content) return { changed: false };
  await fsp.writeFile(filePath, content, 'utf8');
  return { changed: true };
}

export function logStep(msg) {
  console.log(`[docs] ${msg}`);
}

export function exitError(msg) {
  console.error(`[docs:ERROR] ${msg}`);
  process.exit(1);
}

// --- deterministic banner helpers (append to end of file) ---

export function gitLastChangeISO(targetPaths, cwd = process.cwd()) {
  // targetPaths: string | string[]
  const paths = Array.isArray(targetPaths) ? targetPaths : [targetPaths];
  // Only include existing paths to avoid git errors
  const existing = paths
    .map(p => path.resolve(cwd, p))
    .filter(p => fs.existsSync(p));

  if (existing.length === 0) return null;

  try {
    // Get the latest commit date among the provided files/dirs
    // --date=iso-strict gives sortable ISO8601 with timezone
    // Use -- to separate paths safely.
    const cmd = `git log -1 --date=iso-strict --format=%cd -- ${existing.map(p => JSON.stringify(path.relative(cwd, p))).join(' ')}`;
    const out = execSync(cmd, { cwd, stdio: ['ignore', 'pipe', 'ignore'] })
      .toString()
      .trim();
    return out || null;
  } catch {
    return null;
  }
}

export function stableBannerTimestamp(sourcePaths, fallback = null) {
  // Prefer last git change; if not a git repo or no commits, fall back to file mtimes;
  // finally fall back to provided default (e.g., new Date().toISOString()).
  const iso = gitLastChangeISO(sourcePaths);
  if (iso) return iso;

  const paths = Array.isArray(sourcePaths) ? sourcePaths : [sourcePaths];
  let latestMtime = 0;
  for (const p of paths) {
    try {
      const st = fs.statSync(p);
      if (st.mtimeMs > latestMtime) latestMtime = st.mtimeMs;
    } catch {}
  }
  if (latestMtime > 0) return new Date(latestMtime).toISOString();
  return fallback ?? new Date().toISOString();
}

/**
 * Create a standard banner line given a tool name & source paths.
 * Example:
 *   makeBanner("Prisma Schema Docs", ["prisma/schema.prisma"])
 */
export function makeBanner(toolName, sourcePaths) {
  const ts = stableBannerTimestamp(sourcePaths);
  return `<!-- GENERATED by ${toolName} | source last-changed: ${ts} -->`;
}
