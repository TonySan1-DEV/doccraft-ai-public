#!/usr/bin/env node
/* eslint-disable no-console */
import path from 'node:path';
import fs from 'node:fs';
import fsp from 'node:fs/promises';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, '../..');
const SRC_DIR = path.resolve(ROOT, 'src', 'components');
const REFS_DIR = path.resolve(ROOT, 'docs/dev/refs/components');
const INDEX_MD = path.resolve(ROOT, 'docs/dev/06-components.md');
const POSIX = p => p.split(path.sep).join('/');

let writeFileIfChanged, ensureDir, log;
async function initUtils() {
  try {
    const utils = await import('./_utils.mjs');
    writeFileIfChanged = utils.writeFileIfChanged;
    ensureDir = utils.ensureDir;
    log = utils.log ?? ((...a) => console.log('[component-docs]', ...a));
  } catch {
    log = (...a) => console.log('[component-docs]', ...a);
    ensureDir = async dir => fsp.mkdir(dir, { recursive: true });
    writeFileIfChanged = async (file, next) => {
      let prev = null;
      try {
        prev = await fsp.readFile(file, 'utf8');
      } catch {}
      if (prev === next) return { changed: false };
      await ensureDir(path.dirname(file));
      await fsp.writeFile(file, next, 'utf8');
      return { changed: true };
    };
  }
}

const hasFile = p => fs.existsSync(p);
const read = p => fsp.readFile(p, 'utf8');

function detBanner(title) {
  return [
    '<!--',
    ' Auto-generated by scripts/docs/generate-component-docs.mjs',
    ' Title: ' + title,
    ' Deterministic banner (no timestamps).',
    '-->',
    '',
  ].join('\n');
}

// --- TypeScript parsing helpers (best-effort) ---
async function loadTS() {
  try {
    return await import('typescript');
  } catch {
    return null;
  } // graceful fallback if TS not installed
}

function walkDir(start) {
  const out = [];
  const stack = [start];
  while (stack.length) {
    const dir = stack.pop();
    if (!fs.existsSync(dir)) continue;
    for (const ent of fs.readdirSync(dir, { withFileTypes: true })) {
      if (ent.name.startsWith('.')) continue;
      const full = path.join(dir, ent.name);
      if (ent.isDirectory()) {
        if (['dist', 'build', 'node_modules', 'coverage'].includes(ent.name))
          continue;
        stack.push(full);
      } else if (/\.(tsx)$/i.test(ent.name)) {
        out.push(full);
      }
    }
  }
  return out;
}

function getJsDoc(node, ts) {
  const tags = ts.getJSDocTags(node) || [];
  const comment = (ts.getJSDocCommentsAndTags?.(node) || [])
    .map(x => x.comment || '')
    .filter(Boolean)
    .join('\n');
  const summary = comment ? String(comment) : '';
  const byName = {};
  tags.forEach(t => {
    const n = String(
      t.tagName?.escapedText || t.tagName?.text || ''
    ).toLowerCase();
    const c = (t.comment && String(t.comment)) || '';
    byName[n] = byName[n] ? `${byName[n]}\n${c}` : c;
  });
  return { summary, tags: byName };
}

function isReactComponentLike(node, ts) {
  // Heuristics: exported function/const returning JSX, or typed as React.FC/FunctionComponent
  if (!node.modifiers?.some(m => m.kind === ts.SyntaxKind.ExportKeyword))
    return false;

  if (ts.isFunctionDeclaration(node) && node.name) {
    return true;
  }
  if (ts.isVariableStatement(node)) {
    return node.declarationList.declarations.some(d => {
      if (!d.name || !('escapedText' in d.name)) return false;
      return true;
    });
  }
  return false;
}

function getNameFromNode(node, ts) {
  if (ts.isFunctionDeclaration(node) && node.name)
    return String(node.name.escapedText);
  if (ts.isVariableStatement(node)) {
    const d = node.declarationList.declarations[0];
    if (d?.name && 'escapedText' in d.name) return String(d.name.escapedText);
  }
  return 'UnnamedComponent';
}

function findPropsType(node, ts) {
  // Try function component param type: (props: PropsType)
  if (ts.isFunctionDeclaration(node) && node.parameters?.length) {
    const pt = node.parameters[0].type;
    if (pt && pt.kind === ts.SyntaxKind.TypeReference && pt.typeName) {
      return String(
        pt.typeName.escapedText || pt.typeName.right?.escapedText || ''
      );
    }
  }
  // Try variable initializer arrow function: const X: React.FC<Props> = (props) => ...
  if (ts.isVariableStatement(node)) {
    const d = node.declarationList.declarations[0];
    const typeNode = d?.type;
    if (
      typeNode &&
      ts.isTypeReferenceNode(typeNode) &&
      typeNode.typeArguments?.length === 1
    ) {
      const tArg = typeNode.typeArguments[0];
      if (ts.isTypeReferenceNode(tArg) && tArg.typeName) {
        return String(tArg.typeName.escapedText || '');
      }
      if (tArg.kind === ts.SyntaxKind.TypeLiteral) {
        return '__INLINE__';
      }
    }
    // const X = (props: Props) => ...
    if (
      ts.isArrowFunction?.(d?.initializer) &&
      d.initializer.parameters?.length
    ) {
      const pt = d.initializer.parameters[0]?.type;
      if (pt && ts.isTypeReferenceNode(pt) && pt.typeName) {
        return String(pt.typeName.escapedText || '');
      }
      if (pt && pt.kind === ts.SyntaxKind.TypeLiteral) {
        return '__INLINE__';
      }
    }
  }
  return null;
}

function collectTypeMembers(sourceFile, ts, typeName) {
  const results = [];
  // search for interface/type alias with this name
  function addMembersFrom(typeNode) {
    const members = typeNode.members || [];
    for (const m of members) {
      if (!m.name) continue;
      const name = String(m.name.escapedText || '');
      const optional = !!m.questionToken;
      const typeText = m.type
        ? sourceFile.text.slice(m.type.pos, m.type.end).trim()
        : 'any';
      const jd = getJsDoc(m, ts);
      results.push({
        name,
        type: typeText.replace(/\|/g, '\\|').replace(/`/g, '\\`'),
        optional,
        desc: jd.summary || '',
        defaultValue: '',
      });
    }
  }
  sourceFile.forEachChild(node => {
    if (
      ts.isInterfaceDeclaration(node) &&
      String(node.name.escapedText) === typeName
    ) {
      addMembersFrom(node);
    }
    if (
      ts.isTypeAliasDeclaration(node) &&
      String(node.name.escapedText) === typeName &&
      node.type?.members
    ) {
      addMembersFrom(node.type);
    }
  });
  return results;
}

function detectDefaults(node, ts) {
  // try defaultProps or param destructuring defaults
  const defaults = {};
  if (ts.isVariableStatement(node)) {
    // const X = ({ a = 1, b = "x" }: Props) => ...
    const d = node.declarationList.declarations[0];
    const init = d?.initializer;
    if (init && ts.isArrowFunction?.(init) && init.parameters?.length) {
      const p0 = init.parameters[0];
      if (p0.name && ts.isObjectBindingPattern?.(p0.name)) {
        for (const el of p0.name.elements) {
          if (el.initializer && el.name && 'escapedText' in el.name) {
            defaults[String(el.name.escapedText)] = sourceTextFor(
              init.getSourceFile(),
              el.initializer
            );
          }
        }
      }
    }
  }
  // X.defaultProps = { ... }
  const sf = node.getSourceFile();
  const text = sf.text;
  const compName = getNameFromNode(node, ts);
  const re = new RegExp(
    `${compName}\\.defaultProps\\s*=\\s*\\{([\\s\\S]*?)\\}`,
    'm'
  );
  const m = text.match(re);
  if (m) {
    const inner = m[1];
    inner.split(',').forEach(pair => {
      const kv = pair
        .split(':')
        .map(s => s.trim())
        .filter(Boolean);
      if (kv.length >= 2) {
        const k = kv[0].replace(/[\n\r\t ]/g, '');
        const v = kv.slice(1).join(':');
        if (k) defaults[k] = v;
      }
    });
  }
  return defaults;
}

function sourceTextFor(sf, node) {
  try {
    return sf.text
      .slice(node.pos, node.end)
      .trim()
      .replace(/\|/g, '\\|')
      .replace(/`/g, '\\`');
  } catch {
    return '';
  }
}

async function analyzeFile(ts, abs) {
  const rel = POSIX(path.relative(ROOT, abs));
  const text = await read(abs);
  const sf = ts.createSourceFile(abs, text, ts.ScriptTarget.Latest, true);

  const components = [];
  sf.forEachChild(node => {
    if (!isReactComponentLike(node, ts)) return;
    const name = getNameFromNode(node, ts);
    const jd = getJsDoc(node, ts);
    const propsTypeName = findPropsType(node, ts);
    let props = [];
    if (propsTypeName === '__INLINE__') {
      // Inline literal type on parameter
      // naive parse of members from the snippet
      const param = ts.isVariableStatement(node)
        ? node.declarationList.declarations[0]?.initializer?.parameters?.[0]
        : node.parameters?.[0];
      const t = param?.type;
      if (t && t.members?.length) {
        props = t.members.map(m => {
          const nm = String(m.name?.escapedText || '');
          const optional = !!m.questionToken;
          const tText = sf.text.slice(m.type.pos, m.type.end).trim();
          const mJd = getJsDoc(m, ts);
          return {
            name: nm,
            type: tText.replace(/\|/g, '\\|').replace(/`/g, '\\`'),
            optional,
            desc: mJd.summary || '',
            defaultValue: '',
          };
        });
      }
    } else if (propsTypeName) {
      props = collectTypeMembers(sf, ts, propsTypeName);
    }
    const defaults = detectDefaults(node, ts);
    props = props.map(p => ({
      ...p,
      defaultValue: defaults[p.name] || p.defaultValue || '',
    }));

    components.push({
      name,
      file: rel,
      summary: jd.summary || '',
      props,
    });
  });

  return components;
}

function renderComponentPage(c) {
  const lines = [];
  lines.push(detBanner(`Component: ${c.name}`));
  lines.push(`# ${c.name}`);
  lines.push('');
  lines.push(`**File:** \`${c.file}\``);
  lines.push('');
  if (c.summary) {
    lines.push('## Description');
    lines.push(c.summary);
    lines.push('');
  }
  lines.push('## Props');
  if (!c.props.length) {
    lines.push('_No explicit props detected_');
  } else {
    lines.push('');
    lines.push('| Name | Type | Optional | Default | Description |');
    lines.push('|---|---|:---:|---|---|');
    for (const p of c.props) {
      lines.push(
        `| ${p.name} | ${p.type} | ${p.optional ? 'Yes' : 'No'} | ${p.defaultValue ? `\`${p.defaultValue}\`` : ''} | ${p.desc?.replace(/\|/g, '\\|') || ''} |`
      );
    }
  }
  lines.push('');
  return lines.join('\n');
}

function renderIndex(components) {
  const AUTO_START = '<!-- AUTO-GEN:COMPONENTS-START -->';
  const AUTO_END = '<!-- AUTO-GEN:COMPONENTS-END -->';
  const lines = [];
  lines.push(detBanner('Components Index'));
  lines.push('# Components');
  lines.push('');
  lines.push(AUTO_START, '');
  lines.push(`Total components detected: **${components.length}**`, '');
  if (components.length) {
    lines.push('| Component | File |');
    lines.push('|---|---|');
    for (const c of components) {
      const link = `docs/dev/refs/components/${c.name}.md`;
      lines.push(`| [${c.name}](${POSIX(link)}) | \`${c.file}\` |`);
    }
    lines.push('');
  }
  lines.push(AUTO_END, '');
  return { AUTO_START, AUTO_END, text: lines.join('\n') };
}

async function upsertIndex(components) {
  const { AUTO_START, AUTO_END, text } = renderIndex(components);
  let out = text;
  try {
    const existing = await fsp.readFile(INDEX_MD, 'utf8');
    const s = existing.indexOf(AUTO_START);
    const e = existing.indexOf(AUTO_END);
    if (s !== -1 && e !== -1 && e > s) {
      out =
        existing.slice(0, s) +
        text.slice(
          text.indexOf(AUTO_START),
          text.indexOf(AUTO_END) + AUTO_END.length
        ) +
        existing.slice(e + AUTO_END.length);
    } else {
      out = text + '\n' + existing;
    }
  } catch {}
  const res = await writeFileIfChanged(INDEX_MD, out);
  log(
    `${res.changed ? 'updated' : 'unchanged'}: ${POSIX(path.relative(ROOT, INDEX_MD))}`
  );
}

async function main() {
  await initUtils();
  log('start');

  if (!hasFile(SRC_DIR)) {
    log('skip: src/components directory not found.');
    log('done');
    process.exit(0);
  }

  const ts = await loadTS();
  if (!ts) {
    log(
      'skip: typescript module not available; install devDependency to enable deep props.'
    );
  }

  const files = walkDir(SRC_DIR);
  const components = [];
  for (const f of files) {
    if (ts) {
      const cs = await analyzeFile(ts, f);
      components.push(...cs);
    } else {
      // minimal fallback: use filename as component name
      const name = path.basename(f, path.extname(f));
      components.push({
        name,
        file: POSIX(path.relative(ROOT, f)),
        summary: '',
        props: [],
      });
    }
  }

  // Deterministic sort
  components.sort((a, b) => a.name.localeCompare(b.name, 'en'));

  // Write per-component pages
  await ensureDir(REFS_DIR);
  let wroteCount = 0,
    unchangedCount = 0;
  for (const c of components) {
    const file = path.join(REFS_DIR, `${c.name}.md`);
    const res = await writeFileIfChanged(file, renderComponentPage(c));
    if (res.changed) wroteCount++;
    else unchangedCount++;
    log(
      `${res.changed ? 'wrote' : 'unchanged'}: ${POSIX(path.relative(ROOT, file))}`
    );
  }

  // Index
  await upsertIndex(components);

  log(
    `done (${components.length} components; wrote=${wroteCount} unchanged=${unchangedCount})`
  );
  process.exit(0);
}

main().catch(e => {
  console.error('[component-docs] non-fatal error:', e?.message || e);
  process.exit(0);
});
