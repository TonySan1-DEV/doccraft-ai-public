// scripts/docs/generate-prisma-docs.mjs
// ESM, Windows-safe paths, deterministic output, emoji-free, backtick-safe.

import path from 'node:path';
import { execSync } from 'node:child_process';
import * as fs from 'node:fs';
import * as fsp from 'node:fs/promises';

// Utils (guarded import + fallbacks)
let ensureDir, writeFileIfChanged, log;
try {
  const utils = await import(
    path.posix.join('.', 'scripts', 'docs', '_utils.mjs')
  );
  ensureDir = utils.ensureDir;
  writeFileIfChanged = utils.writeFileIfChanged;
  log = utils.log ?? ((...a) => console.log(...a));
} catch (_e) {
  // Minimal local fallbacks
  ensureDir = async dir => {
    await fsp.mkdir(dir, { recursive: true });
  };
  writeFileIfChanged = async (file, next) => {
    let prev = null;
    try {
      prev = await fsp.readFile(file, 'utf8');
    } catch {}
    if (prev === next) {
      return { changed: false };
    }
    await ensureDir(path.dirname(file));
    await fsp.writeFile(file, next, 'utf8');
    return { changed: true };
  };
  log = (...a) => console.log(...a);
}

// --- Helpers (deterministic banner, git read, safe read) ---

function deterministicBanner(title) {
  // HTML comment banner: deterministic (no timestamp), diff-friendly, ASCII only.
  const lines = [
    '<!--',
    ' Auto-generated by scripts/docs/generate-prisma-docs.mjs',
    ' Title: ' + title,
    ' This banner is deterministic (no timestamps) to keep diffs clean.',
    '-->',
    '',
  ];
  return lines.join('\n');
}

async function safeRead(file) {
  try {
    return await fsp.readFile(file, 'utf8');
  } catch {
    return null;
  }
}

function readCommittedFile(posixPath) {
  try {
    // Use POSIX path for git show irrespective of OS
    const out = execSync(`git show HEAD:${posixPath}`, {
      stdio: ['ignore', 'pipe', 'ignore'],
    });
    return out.toString('utf8');
  } catch {
    return null;
  }
}

// Very small diff summary (no heavy diff lib): compare hashes & sizes, plus model count deltas.
function summarizeChange(prevText, nextText, { prevModels, nextModels }) {
  if (prevText === null) {
    return [
      '## Change Summary',
      'No prior committed version detected. Treating as new file.',
      '',
    ].join('\n');
  }
  const prevLen = prevText.length;
  const nextLen = nextText.length;
  const modelDelta = nextModels - prevModels;
  const lenDelta = nextLen - prevLen;
  return [
    '## Change Summary',
    'Models previous: ' + prevModels,
    'Models current: ' + nextModels,
    'Model count delta: ' +
      (modelDelta >= 0 ? '+' + modelDelta : '' + modelDelta),
    'Byte length previous: ' + prevLen,
    'Byte length current: ' + nextLen,
    'Byte length delta: ' + (lenDelta >= 0 ? '+' + lenDelta : '' + lenDelta),
    '',
  ].join('\n');
}

// --- Prisma parsing (tolerant, line-oriented) ---

function parsePrismaSchema(text) {
  // Extract model blocks: model Name { ... }
  const models = [];
  const lines = text.split(/\r?\n/);
  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();
    const m = /^model\s+([A-Za-z0-9_]+)\s*\{/.exec(line);
    if (!m) {
      i++;
      continue;
    }
    const modelName = m[1];
    let depth = 0;
    const block = [];
    // gather block lines
    while (i < lines.length) {
      const raw = lines[i];
      if (raw.includes('{')) depth += (raw.match(/\{/g) || []).length;
      if (raw.includes('}')) depth -= (raw.match(/\}/g) || []).length;
      block.push(raw);
      i++;
      if (depth <= 0) break;
    }
    // Extract fields (skip first line "model X {" and last "}")
    const inner = block
      .slice(1, -1)
      .map(s => s.trim())
      .filter(Boolean);
    const fields = [];
    const indexes = [];
    for (const row of inner) {
      if (row.startsWith('//')) continue;
      if (row.startsWith('@@')) {
        // model-level attributes: @@id, @@unique, @@index, @@fulltext, etc.
        indexes.push(row);
        continue;
      }
      // field: name type attrs...
      // e.g. id        String   @id @default(cuid())
      const parts = row.split(/\s+/);
      if (parts.length >= 2 && /^[A-Za-z_][A-Za-z0-9_]*$/.test(parts[0])) {
        const name = parts[0];
        const type = parts[1];
        const attrs = row.slice(row.indexOf(type) + type.length).trim();
        fields.push({ name, type, attrs });
      }
    }
    models.push({ name: modelName, fields, indexes });
  }
  return { models };
}

function renderModelMarkdown(models) {
  const out = [];
  for (const model of models) {
    out.push('### Model: ' + model.name);
    out.push('');
    if (model.fields.length === 0) {
      out.push('_No fields detected_');
    } else {
      out.push('| Field | Type | Attributes |');
      out.push('|---|---|---|');
      for (const f of model.fields) {
        const attr = f.attrs ? f.attrs.replace(/\|/g, '\\|') : '';
        out.push('| ' + f.name + ' | ' + f.type + ' | ' + attr + ' |');
      }
    }
    out.push('');
    if (model.indexes.length > 0) {
      out.push('Indexes and Model Attributes:');
      for (const idx of model.indexes) {
        out.push('- ' + idx);
      }
      out.push('');
    }
  }
  return out.join('\n');
}

function relationHints(models) {
  // very minimal: look for @relation(â€¦) or type that looks like another model[]
  const out = [];
  for (const m of models) {
    const rels = [];
    for (const f of m.fields) {
      if (/@relation\s*\(/.test(f.attrs || '')) {
        rels.push(f.name + ' -> relation');
      } else if (/\[\]$/.test(f.type)) {
        rels.push(f.name + ' -> many');
      }
    }
    if (rels.length > 0) {
      out.push('- ' + m.name + ': ' + rels.join(', '));
    }
  }
  if (out.length === 0) return '_No obvious relations detected_';
  return out.join('\n');
}

// --- Emit one file ---

async function emitDoc({ schemaPath, outPath, title, mongoCaveat }) {
  const schemaText = await safeRead(schemaPath);
  if (!schemaText) {
    log('[prisma-docs] skip: ' + path.normalize(schemaPath) + ' not found.');
    return { skipped: true };
  }

  const { models } = parsePrismaSchema(schemaText);

  const header = deterministicBanner(title);
  const caveat = mongoCaveat
    ? [
        '### MongoDB Caveat',
        'If you use Prisma re-introspection for MongoDB, it can overwrite manual changes.',
        'Review generated schema carefully and commit intentional edits.',
        '',
      ].join('\n')
    : '';

  // Build markdown (no backticks, no emoji)
  const bodyParts = [];
  bodyParts.push(header);
  bodyParts.push('# ' + title);
  bodyParts.push('');
  if (mongoCaveat) bodyParts.push(caveat);
  bodyParts.push('## Overview');
  bodyParts.push('Models detected: ' + models.length);
  bodyParts.push('');
  bodyParts.push('## Relations (heuristic)');
  bodyParts.push(relationHints(models));
  bodyParts.push('');
  bodyParts.push('## Models');
  bodyParts.push('');
  bodyParts.push(renderModelMarkdown(models));

  // Diff summary vs last commit (best-effort)
  const posixOut = outPath.split(path.sep).join(path.posix.sep);
  const prevCommitted = readCommittedFile(posixOut);
  const nextTextNoSummary = bodyParts.join('\n') + '\n';
  const changeSummary = summarizeChange(prevCommitted, nextTextNoSummary, {
    prevModels: prevCommitted
      ? (prevCommitted.match(/### Model:/g) || []).length
      : 0,
    nextModels: models.length,
  });

  const finalText = nextTextNoSummary + changeSummary;

  const res = await writeFileIfChanged(outPath, finalText);
  log(
    '[prisma-docs] ' +
      (res.changed ? 'wrote: ' : 'unchanged: ') +
      path.normalize(outPath)
  );
  return { skipped: false, changed: res.changed };
}

// --- Main ---

async function main() {
  log('[prisma-docs] start');

  const root = process.cwd();
  const refsDir = path.join(root, 'docs', 'dev', 'refs');
  await ensureDir(refsDir);

  // Postgres
  const pgSchema = path.join(root, 'prisma', 'schema.prisma');
  const pgOut = path.join(refsDir, 'prisma-pg.schema.md');

  // Mongo
  const mongoDir = path.join(root, 'prisma-mongodb');
  const mongoSchema = path.join(mongoDir, 'schema.prisma');
  const mongoOut = path.join(refsDir, 'prisma-mongo.schema.md');

  let pgStatus = 'skipped';
  if (fs.existsSync(path.dirname(pgSchema)) && fs.existsSync(pgSchema)) {
    const r = await emitDoc({
      schemaPath: pgSchema,
      outPath: pgOut,
      title: 'Prisma Schema (PostgreSQL)',
    });
    pgStatus = r.skipped ? 'skipped' : r.changed ? 'updated' : 'unchanged';
  } else {
    log('[prisma-docs] skip: prisma directory or schema.prisma not found.');
  }

  let mongoStatus = 'skipped';
  if (fs.existsSync(mongoDir) && fs.existsSync(mongoSchema)) {
    const r = await emitDoc({
      schemaPath: mongoSchema,
      outPath: mongoOut,
      title: 'Prisma Schema (MongoDB)',
      mongoCaveat: true,
    });
    mongoStatus = r.skipped ? 'skipped' : r.changed ? 'updated' : 'unchanged';
  } else {
    log(
      '[prisma-docs] skip: prisma-mongodb directory or schema.prisma not found.'
    );
  }

  log('[prisma-docs] done');
  log('[prisma-docs] summary: pg=' + pgStatus + ' mongo=' + mongoStatus);
  process.exit(0);
}

main();
