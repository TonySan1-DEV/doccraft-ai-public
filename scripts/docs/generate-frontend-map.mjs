// scripts/docs/generate-frontend-map.mjs
// Purpose: Generate route-map.json and component-map.json by scanning the React codebase,
// then summarize into docs/dev/04-frontend.md inside an AUTO-GEN block.
// - Tooling-only, deterministic (no timestamps in files), write only on change.
// - Friendly skips (exit 0) if src/ not found.
//
// Notes:
// - Heuristics support React Router v6 in both JSX (<Route path="â€¦">) and
//   object-based (createBrowserRouter/useRoutes) styles.
// - Component map collects default and named React components from *.tsx/*.jsx
//   (lightweight parsing). Also counts naive usage via imports/JSX tags.

import fs from 'node:fs/promises';
import path from 'node:path';

// Reuse project utils if available; fall back to local minimal impls.
let ensureDir, writeFileIfChanged, log, makeBanner;
(async () => {
  try {
    const utils = await import(
      path.join(process.cwd(), 'scripts/docs/_utils.mjs')
    );
    ensureDir = utils.ensureDir;
    writeFileIfChanged = utils.writeFileIfChanged;
    log = utils.log || ((...a) => console.log('[frontend-map]', ...a));
    makeBanner = utils.makeBanner;
  } catch {
    ensureDir = async p => {
      await fs.mkdir(p, { recursive: true });
    };
    writeFileIfChanged = async (filePath, content) => {
      let prev = null;
      try {
        prev = await fs.readFile(filePath, 'utf8');
      } catch {}
      if (prev !== content) {
        await ensureDir(path.dirname(filePath));
        await fs.writeFile(filePath, content, 'utf8');
        return { changed: true };
      }
      return { changed: false };
    };
    log = (...a) => console.log('[frontend-map]', ...a);
    makeBanner = (toolName, sourcePaths) =>
      `<!-- GENERATED by ${toolName} | source last-changed: ${new Date().toISOString()} -->`;
  }

  const ROOT = process.cwd();
  const SRC_DIR = path.join(ROOT, 'src');
  const DOCS_DIR = path.join(ROOT, 'docs', 'dev');
  const REFS_DIR = path.join(DOCS_DIR, 'refs');
  const ROUTE_JSON = path.join(REFS_DIR, 'route-map.json');
  const COMP_JSON = path.join(REFS_DIR, 'component-map.json');
  const FRONTEND_MD = path.join(DOCS_DIR, '04-frontend.md');

  const exists = async p => !!(await fs.stat(p).catch(() => null));
  const read = async p => fs.readFile(p, 'utf8');
  const writeIfChanged = writeFileIfChanged;
  const toPosix = p => p.split(path.sep).join('/');

  async function walk(dir, exts = ['.tsx', '.jsx', '.ts', '.js']) {
    const out = [];
    const stack = [dir];
    while (stack.length) {
      const cur = stack.pop();
      let ents;
      try {
        ents = await fs.readdir(cur, { withFileTypes: true });
      } catch {
        continue;
      }
      for (const ent of ents) {
        const p = path.join(cur, ent.name);
        if (ent.isDirectory()) {
          if (
            [
              'node_modules',
              'dist',
              'build',
              '.next',
              '.turbo',
              '.output',
            ].includes(ent.name)
          )
            continue;
          stack.push(p);
        } else {
          if (exts.includes(path.extname(ent.name))) out.push(p);
        }
      }
    }
    return out.sort((a, b) => a.localeCompare(b));
  }

  // --- ROUTE EXTRACTION (heuristics) ---
  function extractRoutesFromText(text, file) {
    const routes = [];

    // JSX style: <Route path="/x" element={<Comp />} ... />
    const routeTagRe = /<Route\s+([^>]+)>?/g;
    let m;
    while ((m = routeTagRe.exec(text)) !== null) {
      const attrs = m[1];
      const pathM = /(?:^|\s)path\s*=\s*["'`]([^"'`]+)["'`]/.exec(attrs);
      const idxM = /(?:^|\s)index(?:\s|=|>)/.exec(attrs);
      if (!pathM && !idxM) continue;
      let component = null;
      const elM1 = /element\s*=\s*\{\s*<\s*([A-Za-z0-9_.$]+)\b/.exec(attrs);
      const elM2 = /Component\s*=\s*\{\s*([A-Za-z0-9_.$]+)\s*\}/.exec(attrs); // lazy route props
      if (elM1) component = elM1[1];
      else if (elM2) component = elM2[1];
      routes.push({
        kind: 'jsx',
        file: toPosix(path.relative(ROOT, file)),
        path: pathM ? pathM[1] : '(index)',
        component: component || null,
      });
    }

    // Object style: path: "/x", element: <Comp />
    const pathRe = /path\s*:\s*["'`]([^"'`]+)["'`]/g;
    let pm;
    while ((pm = pathRe.exec(text)) !== null) {
      const pth = pm[1];
      // Look ahead a bit for element: <Comp />
      const slice = text.slice(pm.index, pm.index + 400);
      const el = /element\s*:\s*<\s*([A-Za-z0-9_.$]+)\b/.exec(slice);
      routes.push({
        kind: 'object',
        file: toPosix(path.relative(ROOT, file)),
        path: pth,
        component: el ? el[1] : null,
      });
    }

    return routes;
  }

  // --- COMPONENT EXTRACTION (heuristics) ---
  function extractComponentsFromText(text, file) {
    const comps = new Set();

    // export default function Name(
    (
      text.match(/export\s+default\s+function\s+([A-Za-z0-9_]+)/g) || []
    ).forEach(s => {
      const m = /export\s+default\s+function\s+([A-Za-z0-9_]+)/.exec(s);
      if (m) comps.add(m[1]);
    });

    // export function Name(
    (text.match(/export\s+function\s+([A-Za-z0-9_]+)\s*\(/g) || []).forEach(
      s => {
        const m = /export\s+function\s+([A-Za-z0-9_]+)\s*\(/.exec(s);
        if (m) comps.add(m[1]);
      }
    );

    // export const Name = (...) => or = function
    (
      text.match(
        /export\s+const\s+([A-Za-z0-9_]+)\s*=\s*(?:async\s+)?(?:\([^)]*\)|[A-Za-z0-9_]+)\s*=>/g
      ) || []
    ).forEach(s => {
      const m = /export\s+const\s+([A-Za-z0-9_]+)/.exec(s);
      if (m) comps.add(m[1]);
    });
    (
      text.match(/export\s+const\s+([A-Za-z0-9_]+)\s*=\s*function\b/g) || []
    ).forEach(s => {
      const m = /export\s+const\s+([A-Za-z0-9_]+)/.exec(s);
      if (m) comps.add(m[1]);
    });

    // default export identifier (export default Name)
    (text.match(/export\s+default\s+([A-Za-z0-9_]+)/g) || []).forEach(s => {
      const m = /export\s+default\s+([A-Za-z0-9_]+)/.exec(s);
      if (m) comps.add(m[1]);
    });

    // Try to pick Props type for default/named function signature
    // function Name(props: SomethingProps
    const propsByComp = {};
    const fnSigRe =
      /function\s+([A-Za-z0-9_]+)\s*\(\s*([A-Za-z0-9_{}[\]\s,:?=]+)\)/g;
    let f;
    while ((f = fnSigRe.exec(text)) !== null) {
      const name = f[1];
      const params = f[2] || '';
      const propsType = /:\s*([A-Za-z0-9_$.]+)/.exec(params);
      if (propsType) propsByComp[name] = propsType[1];
    }

    return { names: [...comps], propsByComp };
  }

  // --- USAGE COUNT (import/JSX tag heuristics) ---
  function countUsages(allTexts, compName) {
    const tag = new RegExp(`<(?:${compName})(\\s|>)`, 'g');
    const imp = new RegExp(
      `\\bimport\\s+\\{[^}]*\\b${compName}\\b[^}]*\\}\\s+from\\s+["'][^"']+["']`,
      'g'
    );
    const impDef = new RegExp(
      `\\bimport\\s+${compName}\\s+from\\s+["'][^"']+["']`,
      'g'
    );
    let c = 0;
    for (const t of allTexts) {
      c += (t.match(tag) || []).length;
      c += (t.match(imp) || []).length;
      c += (t.match(impDef) || []).length;
    }
    return c;
  }

  async function main() {
    log('start');
    if (!(await exists(SRC_DIR))) {
      log('skip: src/ not found, nothing to analyze.');
      log('done');
      return;
    }

    await ensureDir(REFS_DIR);

    const files = await walk(SRC_DIR, ['.tsx', '.jsx', '.ts', '.js']);
    const texts = await Promise.all(files.map(f => read(f).catch(() => '')));

    // Build route list
    const routes = [];
    for (let i = 0; i < files.length; i++) {
      const rts = extractRoutesFromText(texts[i], files[i]);
      if (rts.length) routes.push(...rts);
    }

    // Deduplicate by (path, component, file, kind)
    const seen = new Set();
    const uniqRoutes = [];
    for (const r of routes) {
      const key = `${r.kind}::${r.path}::${r.component ?? ''}::${r.file}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqRoutes.push(r);
      }
    }
    uniqRoutes.sort(
      (a, b) =>
        (a.path || '').localeCompare(b.path || '') ||
        a.file.localeCompare(b.file)
    );

    // Components: scan and count usages
    const compIndex = {}; // name -> { files: Set<string>, propsType?: string, usage: number }
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const text = texts[i];
      const { names, propsByComp } = extractComponentsFromText(text, file);
      for (const n of names) {
        if (!compIndex[n])
          compIndex[n] = { files: new Set(), propsType: null, usage: 0 };
        compIndex[n].files.add(toPosix(path.relative(ROOT, file)));
        if (propsByComp[n] && !compIndex[n].propsType)
          compIndex[n].propsType = propsByComp[n];
      }
    }

    const allTexts = texts;
    for (const n of Object.keys(compIndex)) {
      compIndex[n].usage = countUsages(allTexts, n);
    }

    const compEntries = Object.entries(compIndex)
      .map(([name, info]) => ({
        name,
        files: [...info.files].sort(),
        propsType: info.propsType || null,
        usage: info.usage || 0,
      }))
      .sort((a, b) => b.usage - a.usage || a.name.localeCompare(b.name));

    // Write JSON refs
    const routeJson =
      JSON.stringify(
        { generatedBy: 'generate-frontend-map', routes: uniqRoutes },
        null,
        2
      ) + '\n';
    const compJson =
      JSON.stringify(
        { generatedBy: 'generate-frontend-map', components: compEntries },
        null,
        2
      ) + '\n';

    const r1 = await writeIfChanged(ROUTE_JSON, routeJson);
    log(
      `${r1.changed ? 'wrote' : 'unchanged'}: ${toPosix(path.relative(ROOT, ROUTE_JSON))}`
    );

    const r2 = await writeIfChanged(COMP_JSON, compJson);
    log(
      `${r2.changed ? 'wrote' : 'unchanged'}: ${toPosix(path.relative(ROOT, COMP_JSON))}`
    );

    // Write/update 04-frontend.md (AUTO-GEN block)
    const autoStart = '<!-- AUTO-GEN:FRONTEND-START -->';
    const autoEnd = '<!-- AUTO-GEN:FRONTEND-END -->';

    const summaryMdLines = [];
    summaryMdLines.push(autoStart);
    summaryMdLines.push('');
    summaryMdLines.push('### Route & Component Summary (auto-generated)');
    summaryMdLines.push('');
    summaryMdLines.push(`- Total routes detected: **${uniqRoutes.length}**`);
    summaryMdLines.push(
      `- Total unique components exported: **${compEntries.length}**`
    );
    summaryMdLines.push('');

    // Sample: first 15 routes
    const sampleRoutes = uniqRoutes.slice(0, 15);
    if (sampleRoutes.length) {
      summaryMdLines.push('**Sample routes (first 15):**');
      summaryMdLines.push('');
      summaryMdLines.push('| Path | Component | File | Kind |');
      summaryMdLines.push('|---|---|---|---|');
      for (const r of sampleRoutes) {
        summaryMdLines.push(
          `| \`${r.path}\` | \`${r.component ?? ''}\` | \`${r.file}\` | \`${r.kind}\` |`
        );
      }
      summaryMdLines.push('');
    } else {
      summaryMdLines.push('_No routes detected by heuristics._');
      summaryMdLines.push('');
    }

    // Top components by usage (first 15)
    const topComps = compEntries.slice(0, 15);
    if (topComps.length) {
      summaryMdLines.push('**Top components by usage (first 15):**');
      summaryMdLines.push('');
      summaryMdLines.push('| Component | Usage | Props Type | Files |');
      summaryMdLines.push('|---|---:|---|---|');
      for (const c of topComps) {
        const filesShort =
          c.files
            .slice(0, 2)
            .map(f => `\`${f}\``)
            .join(', ') +
          (c.files.length > 2 ? `, +${c.files.length - 2} more` : '');
        summaryMdLines.push(
          `| \`${c.name}\` | ${c.usage} | \`${c.propsType ?? ''}\` | ${filesShort} |`
        );
      }
      summaryMdLines.push('');
    } else {
      summaryMdLines.push('_No components detected._');
      summaryMdLines.push('');
    }

    summaryMdLines.push(autoEnd);
    summaryMdLines.push('');

    const autoBlock = summaryMdLines.join('\n');

    let md = '';
    if (await exists(FRONTEND_MD)) {
      md = await read(FRONTEND_MD);
      if (md.includes(autoStart) && md.includes(autoEnd)) {
        const updated = md.replace(
          new RegExp(`${autoStart}[\\s\\S]*?${autoEnd}`),
          autoBlock
        );
        if (updated !== md) {
          const w = await writeIfChanged(FRONTEND_MD, updated);
          log(
            `${w.changed ? 'wrote' : 'unchanged'}: ${toPosix(path.relative(ROOT, FRONTEND_MD))}`
          );
        } else {
          log(`unchanged: ${toPosix(path.relative(ROOT, FRONTEND_MD))}`);
        }
      } else {
        // Append block at end, preserve author content
        const frontendBanner = makeBanner('Frontend Route & Component Map', [
          'src',
        ]);
        const merged =
          frontendBanner + '\n\n' + md.trimEnd() + '\n\n' + autoBlock + '\n';
        const w = await writeIfChanged(FRONTEND_MD, merged);
        log(
          `${w.changed ? 'wrote' : 'unchanged'}: ${toPosix(path.relative(ROOT, FRONTEND_MD))}`
        );
      }
    } else {
      // Create skeleton file
      const frontendBanner = makeBanner('Frontend Route & Component Map', [
        'src',
      ]);
      const skeleton =
        [
          frontendBanner,
          '# Frontend Overview',
          '',
          'This document summarizes routes and components detected by static analysis.',
          '',
          autoBlock,
        ].join('\n') + '\n';
      const w = await writeIfChanged(FRONTEND_MD, skeleton);
      log(
        `${w.changed ? 'wrote' : 'unchanged'}: ${toPosix(path.relative(ROOT, FRONTEND_MD))}`
      );
    }

    log('done');
  }

  main().catch(e => {
    console.warn('[frontend-map] error:', e?.message || e);
    // Non-fatal: ensure exit 0
  });
})();
